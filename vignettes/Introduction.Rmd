---
title: "Introduction to GUSMap"
author: "Timothy P. Bilton"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Introduction to GUSMap}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set( collapse = TRUE, comment = "#>", eval=FALSE)
```

In this tutorial, we will describe how to use GUSMap to perform linkage mapping and explain some of the functionality available. 

For this tutorial, we will use a simualated dataset of a full-sib family (F1 population) consisting of 100 offspring, 3 chromosomes and 1000 SNPs to illustrate GUSMap. The file location to the VCF file (and associated pedigree file) for the dataset can be extracted using the `simDS` function.

```{r simDS}
vcffile <- simDS() # extract filename
vcffile            # filename stored in object vcffile
```

Some important up front comments regarding GUSMap:

1. Having high read depth on the parents (e.g., sequencing more than once) can be hugely helpful to correctly infer the segregation type of more SNPs. However, for the progeny, it is of more value (and cost-efficient) to have more individuals in the family at lower depth than sequence fewer at higher depth.
2. GUSMap is designed for low coverage sequencing data which means that there is no need to pre-filter the data in terms of read depth. Furthermore, GUSMap includes standard filtering steps in terms of minor allele frequemcy (MAF), missing data and segregation test (including a few other filters) which means one only needs to input a raw Variant Call Format (VCF) file obtained after the SNP calling processes.

## Loading Data

At present, GUSMap can read in data stored in Variant Call Format (VCF) file, provided that there is some form of allelic depth information (e.g., the number of reads for the reference and alternate alleles). This is done using the `VCFtoRA` function which takes in the name of a VCF file and converts it into what we call a reference/alternate (RA) file.

```{r loadData}
# convert VCF file to an RA file
rafile <- VCFtoRA(infilename = vcffile$vcf, direct = "./", makePed=TRUE)
```

The arguments of the `VCFtoRA` function are:

1. `infilename`: The name of the VCF file. 
2. `direct`: Specifies which directory to write the RA file to (relative to the current working directory).
3. `makePed`: Specifies whether or not to initalize a pedigree file. Pedigree files are inportant for creating a full-sib family object and will be discussed later. 

Currently, `VCFtoRA` requires one of the fields **AD**, **AO and RO**, or **DP4** to be present in the VCF file to extract allelic depth information. One other thing to note is that `VCFtoRA` returns the file location of the created RA file.
```{r rafile}
rafile # file path of RA file
```

The RA file created is a tab-delimited file with columns, **CHROM** (the chromosome name taken from the "#CHROM" column in the VCF file), **POS** (the position of the SNP taken from the "POS" column in the VCF file), and **SAMPLES** which consists of the sampleIDs used in the VCF (columns 10 and above in the VCF file). For example, the first five columns and rows of the RA file for the simulated dataset are:

|CHROM	|POS	   |P1_1  |P2_1 |P1_2 |
|:------|:-------|:-----|:----|:----|
|1	    |866499	 |25,0  |0,2  |9,0  |
|1	    |2070050 |8,0   |4,9  |9,0  |
|1	    |2232468 |1,0	  |0,1  |2,0  |
|1	    |3459263 |12,13 |0,0  |0,1  |

Note: Indels are and multiple alternative alleles are removed, and ./. is translated into 0,0.

An RA file can then be loaded into R using the `readRA` function.
```{r readRA}
RAdata <- readRA(rafile = rafile, sampthres = 0.01, excsamp = NULL)
```

The arguments of the `readRA` function are:

1. `rafile`: Name of the RA file to be read in.
2. `sampthres`: Specifies the minimum sample depth of an individual before it is removed.
3. `excsamp`: Specifies sample IDs of any samples in the RA to be discarded (to problematic samples to be removed). The input for `excsamp` must correspond to the sample IDs in the RA file.

The RA data is now stored as an `RA` object.
```{r class_RAdata}
class(RAdata)
```

Summary information of the RA object can be displayed by printing the object.
```{r RAdata}
RAdata
```

## Linkage mapping with GUSMap

In this section, we will discuss linkage mapping using GUSMap. The main steps to the process are:

1. Create a full-sib family and perform appropriate filtering
2. Constructing linkage groups
3. Ordering markers across each linakge group
4. Computing maps for the ordered linkage groups

In the following sections, we shall discuss how each of these steps are performed in GUSMap.

### Constructing a full-sib family

Construction of a 'full-sib' family (e.g., F1 population) object is achieved using the `makeFS` function.
```{r makeFS}
mySpecies <- makeFS(RAobj = RAdata, pedfile = vcffile$ped, 
                      filter = list(MAF = 0.05, MISS = 0.5,
                        BIN = 100, DEPTH = 5, PVALUE = 0.01))
```

The `makeFS()` function takes an `RA` object and performs

There are five different types of filtering available in GUSMap:

* Minor allele frequency (`MAF`): SNPs are removed if the MAF is below the threshold since in full-sib families, the expected allele frequency ratios are 0.5 for BI SNPs and 0.75 (or 0.25) for PI and MI SNPs.
* Percentage of missing data (`MISS`): SNPs are removed if the number of individuals without a single read for a given SNP is less than the threshold. 
*      (`BIN`): This filter is performed to  
* Parental Depth (`DEPTH`): SNPs are removed if the read depth of each parent is below the threshold value. This filtering is performed since low read depth can result in parental heterozygous genotypes to be seen as homozygous resulting in incorrectly inferred segreation type.  
* Segregation test (`PVALUE`): A segregation test is performed to removed any SNPs in which the segregation type has been incorrectly inferred (e.g., parental genotypes called wrongly).



### Linkage Groups:

#### Computing 2-point recombination fraction estimates

Linkage group formation in GUSMap is based on 2-point recombination fraction estimates and associated LOD scores between all pairs of SNPs. These are computed using the function `$rf_2pt`. 
```{r 2pt_rf}
mySpecies$rf_2pt(nClust = 3)
```

The `$rf_2pt` function is parallelized to reduce computational time, where the `nClust` argument sepcifies how many cores to use in the parallelization. Be careful not to set this to more than what is available on your computer. Note: this step can take some time, especially if there are a large number of SNPs in your dataset. 

##### Genome Assembly Validation 

Once the 2-point recombination fraction estimates and associated LOD scores have been computed, we can plot the resulting estimates on a heatmap.
```{r plotChr}
# plot 2-point rf matrix for BI and MI SNPs
mySpecies$plotChr(mat = "rf", parent = "maternal",lmai=0.5)
```

Heatmaps are helpful for examining genome assemblies if the SNPs where called using a reference genome. One can still plot the 2-point rf's estimates for *de novo* assemblies, although the resulting plot should look fairly random and so is usually not very informative.

One can also plot the matrix of 2-point LOD scores.
```{r plotChr}
# plot 2-point LOD matrix for BI, PI and MI SNPs
mySpecies$plotChr(mat = "LOD", parent = "both", lmai=0.5)
```

In the above code, the `parent` argument has been set to `"both"` which means that all the SNPs will be plotted. 


#### Forming linkage groups

Using our 2-point rf estimates and LOD scores, we can proceed to forming linkage groups. 
```{r createLG}
mySpecies$createLG(parent = "both", LODthres = 5, nComp = 10)
mySpecies
```

The process of creating linkage groups in GUSMap is as follows:

1. the two SNPs with the highest LOD score are grouped together to form the first linkage group. If the highest LOD score is less than the LOD threshold, then the SNPs are not grouped togehter and no linkage groups are formed. In this case, lower your LOD threshold.
2. The SNP was the 
3. Once there are no more SNPs with an average LOD with the largest `nComp` SNPs is less than the LOD threshold, then we proceed back to step 1 and form a new linkage group. 
4. Stop when no more linkage groups can be formed and no more SNPs are added to a linkage group or all the SNPs have been 

`parent = "maternal"` to create linkage groups for maternal SNPs only and `parent = "paternal"` to create linkage groups for paternal SNPs only. The second argument is the LOD threshold to use in forming the linkage groups. 

Once the linkage groups have been formed, it is a good idea to look how well the grouping has performed by examining the heatmap of the 2-point rf estimates with the SNPs grouped according to the linkage groups
```{r plotLG_mat}
mySpecies$plotLG(parent = "maternal")
```

So we see that the MI SNPs have grouped into three linkage groups, which is what we expect given that we know there was 3 chromosomes to start, and the MI SNPs between linkage groups appear relately unlinked with high rf estimates.

Now we examine the PI linkage groups.
```{r plotLG_pat}
mySpecies$plotLG(parent = "paternal")
```

Lastly, one can also examine the heatmap of the rf matrix for all the linkage groups.
```{r plotLG_pat}
mySpecies$plotLG(parent = "both")
```

This is useful to investiage whether there are any MI linkage groups that have high rf with a MI linkage group. If this is the case, then this would suggest that the linkage groups should be on the same parental meiosis. In our example, we see that linkage group 2 has high rf with linkage group 6. Since linkage group 6 has many more SNPs that linkage group 2, it seems most likely that the segregation type for the SNPs in linkage group 2 were incorrectly determined to be MI instead of PI (possibly due to sequencing errors and low read depth)

##### Editing Linkage Groups

After forming linkage groups, it is important to . Ideally, one should obtain as many linkage groups as the number of chromosomes the species is known to have. However, in practice, teh number of linkage graoups may be more or less than the number of chromosomes depending on the LOD threshold used and whether there are enough SNPs closer 

For our simulated data, we had four MI linkage groups (one more than the number of chromosomes being 3) and only 2 PI groups. From the heatmaps above, we see that linkage group 5 appears to be two separate linkage groups and so need to be split up. The best way to do this is recreating the linkage groups using a high LOD score.
```{r createLG_pat}
mySpecies$createLG(parent = "paternal", LODthres = 10, nComp = 10)
mySpecies
```

Note: the `parent` argument is set to `"paternal"` which means that we are only recreating the PI linkage groups. So, we now see that with a LOD threshold of 10, there are now four PI linkage groups. Again, we examine the heatmap.
```{r plotLG_pat2}
mySpecies$plotLG(parent = "paternal")
```

So, the fifth linkage group with 2 SNPs appears to have some linkage with SNPs in linkage group 4. However, the linkage is only with a few and has rf values of close to 0.5 with most of the other SNPs, so these may be spurious. There are two options that should be considered here.

1. To merge linkage groups 4 and 5. This can 
2. To discard linkage group 5

However, we will take the more caution option and remove the linkage group. There are two ways of achieving this. One is to remove the entire linkage group.
```{r removeLG}
mySpecies$removeLG(LG = 6)
mySpecies
```

Alternatively, one could have also remove the SNPs in the linkage group.
```{r removeSNP, eval=FALSE}
mySpecies$removeSNP(snps = c(526,527))
```

The `$removeSNPs` function is more useful for removing a single SNP from a linkage group if it appears problematic whitout deleting the entire linkage group.

Figure ? above also suggested that linkage group 2 should be with was linkage group 6 but is now linkage group 7. We can merge these two linkage groups using the `$mergeLG` function.
```{r mergeLG}
mySpecies$mergeLG(LG = c(2,7), mergeTo="paternal")
```


**Note:** At this stage there is no undo funcationality in GUSMap. So, once you have removed a SNP or linkage group, or merge two linkage groups. However, if you do edit the linkage groups unintentionally, then you can just recreate the linkage groups using the `$createLG` and proceed as you going before (and hence it helps to save you code in a script).

#### Adding Both-Informative SNPs

When the maternal and parental linkage groups have been tidies up and any probmatic SNPs removed, we can proceed to map the BI SNPs to the linkage groups and merge the linkage groups across the two parental lines. 
```{r addBIsnps}
mySpecies$addBIsnps(LODthres = 10, nComp = 10)
```

Once again the linkage groups should be examine using heatmaps of the 2-point rf estimates and editing accordingly if required.

### Ordering Linkage Groups

Once we are happy with the linkage groups that we have formed, we can proceed to order the markers (SNPs) in each linkage group. In GUSMap, marker ordering is performed using the multidimensional scaling approach as described by ? (2018) and is implmented in the `$orderLG` function.
```{r orderLG}
mySpecies$orderLG() 
```

```{r removeSNP_2}
mySpecies$removeSNP(snps=c(166,173, 310))
```



