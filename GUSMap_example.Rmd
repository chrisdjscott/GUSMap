---
title: "GUSMap_example"
author: "Timothy Bilton"
date: "14 June 2018"
output: html_document
---

```{r setup, include=FALSE, echo=FALSE}
knitr::opts_chunk$set(echo = TRUE, eval=TRUE)
```

```{r, echo=FALSE}
#install.packages("devtools", repos="https://cran.stat.auckland.ac.nz/")
library(devtools)
#install_github("tpbilton/GUSMap", ref="Development")
library(GUSMap)
#install.packages("onemap", repos="https://cran.stat.auckland.ac.nz/")
library(onemap)
```

# Code for testing GUSMap

## Example 1: Manuka dataset 

This example is a recode of the example given in the README file for the master branch (with a few slight additions).

#### Read in data
```{r}
## get file paths to Manuka data
MKdata <- Manuka11()
## Convert VCF to RA
RAfile <- VCFtoRA(MKdata$vcf)
## read in the RA fill
RAdata <- readRA(RAfile, gform = "reference")
```
The above functions are merely to read in data. *VCFtoRA* is probably the slowest and can take 5-10 minutes for a large datasets (e.g. 400,000 SNPs).

#### Create a mapping population

```{r}
MK_fs <- makeFS(RAdata, pedfile=MKdata$ped)
```
The above function processes (including some filtering) the RA file into a format required for a full-sib family. There are a whole bunch of things going inside this function.  

#### Compute pairwise rf's

Now, we need to compute all the pairwise recombination fraction estimates between all pairs of SNPs.
```{r}
MK_fs$rf_2pt(nClust=3)
```
The above function is very slow because it is taking each pair of SNPs and computing a likelihood to get a point estimate. *nClust* argument specifies the number of cores to use with the parallelization within the function using the *foreach* R package.

Heatmaps of these estimates are
```{r}
MK_fs$plotChr(parent = "maternal")
MK_fs$plotChr(parent = "paternal")
```

#### Mask SNPs

The code below is just to mask some SNPs to get the same results as in the paper by Bilton et al. (2018). Heatmaps are again produced to check output.
```{r}
##Want to mask the SNPs know to be bad
badSnps <- rep(FALSE, MK_fs$.__enclos_env__$private$nSnps)
badSnps[c(3:14,16,18:23,25:27,29,33:35,39:42,44,46:49, 
   53,58:60,63,65:67,69:74,76,77,85,104,114:129, 
   152,162,163,173:180,187:190,206:208,210,212,213, 
   216,228,272,285,286,298,304,314,318,320,342,344,345, 
   354,358,370,373,380,389,390,397,408,411,421,427, 
   437,446,469,493,498:500,506,510,516,519,522,531, 
   543,553,556,569,582,585,601,617,620,623,628,635, 
   636:643,647:650,669:680)] <- TRUE 
MK_fs$maskSNP(which(badSnps))
MK_fs$plotChr()
MK_fs$plotChr(parent = "paternal")
```

#### Compute the linkage maps for SNPs on chromosome 11

```{r rf}
depth <- MK_fs$.__enclos_env__$private$ref[[1]] + MK_fs$.__enclos_env__$private$alt[[1]]
rd6 <- ((colMeans(depth) > 6) | badSnps)
MK_fs$maskSNP(which(rd6))
## Compute the rf estimates
## using optim 
MK_fs$rf_est(method="optim")
sum(haldane(MK_fs$para$rf_p[[1]])) ## should be 76.09481
MK_fs$para$ep[[1]]                 ## should be 0.003167973
## using EM algorithm
MK_fs$rf_est(method="EM")
sum(haldane(MK_fs$para$rf_p[[1]])) ## should be 76.09481
MK_fs$para$ep[[1]]                 ## should be 0.003167973

```
The *MK_fs$rf_est()* is the main function here and is solving the likelihood for a hidden Markov model (HMM). The likelihood is written as C functions and are in the src folder. There is also two different optimization routines:

* Direct maximization: Using the *optim* function in R with the C scripts *likelihoods.c* and *score.c* being called.
* Expectation-Maximization (EM) algorithm. Uses the *em.c* C script.

## Example 2: Large data set:

For a larger dataset, I'll simulate some ideal data below (for two chromosomes)
```{r}
noChr=5
nSnps=50
noFam=1
set.seed(5721)
config <- list(sapply(1:noChr, function(x) list(sample(c(1,2,4),size=nSnps, prob=c(1,2,2)/5, replace=T)), simplify=T))
simData <- simFS(1/nSnps,epsilon=0.01,config=config,nInd=200, meanDepth=5, noChr=noChr, seed1=687534, seed2=6772)
```

Again compute the pairwise recombination fraction estimates between all pairs of SNPs.
```{r}
simData$rf_2pt(nClust=3)
## plot the results
simData$plotChr(parent="maternal")
simData$plotChr(parent="paternal")
```

Solve the likelihood for the hidden Markov model (HMM) and get recombination fraction estimates
```{r}
simData$rf_est(method="optim")
## Chromosome 1
sum(haldane(simData$para$rf_p[[1]])) ## Should be 98.41231
simData$para$ep[[1]]                 ## 0.01010545
## Chromosome 2
sum(haldane(simData$para$rf_p[[2]])) ## Should be 103.2207 
simData$para$ep[[2]]                 ## 0.009815709
```

